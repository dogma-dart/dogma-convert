
library dogma_data.build;

//---------------------------------------------------------------------
// Standard libraries
//---------------------------------------------------------------------

import 'dart:async';
import 'dart:io';

//---------------------------------------------------------------------
// Imports
//---------------------------------------------------------------------

import 'package:args/args.dart';
import 'package:cli_util/cli_util.dart';
import 'package:dogma_data/src/analyzer/analyzer_metadata.dart';
import 'package:dogma_data/src/analyzer/context.dart';
import 'package:dogma_data/src/codegen/library_generator.dart';
import 'package:dogma_data/src/metadata/library_metadata.dart';
import 'package:path/path.dart' as path;

Future<Null> build(List<String> args,
                   String packageName,
                   String rootLibrary,
                  {bool unmodifiable: true,
                   bool converters: true,
                   String unmodifiableLibrary: 'lib/unmodifiable_model_views.dart',
                   String unmodifiablePath: 'lib/src/unmodifiable_model_views',
                   String converterLibrary: 'lib/convert.dart',
                   String converterPath: 'lib/src/convert',
                   String header: ''}) async
{
  // Parse the arguments
  var parser = new ArgParser()
      ..addFlag('machine', defaultsTo: false)
      ..addOption('changed', allowMultiple: true)
      ..addOption('removed', allowMultiple: true);

  var parsed = parser.parse(args);

  // Get the analysis context
  var currentPath = _normalizePathSeparators(path.current);
  var context = analysisContext(currentPath, getSdkDir().path);

  // Determine the caller
  //
  // If the machine flag is present then this was called by build_system and an
  // incremental build can be performed. Otherwise assume that a full rebuild
  // has been requested.
  if (parsed['machine']) {
    return;
  } else {

  }

  var metadata = libraryMetadata(rootLibrary, context);

  header = '// Generated by dogma_data. DO NOT MODIFY!\n// ${new DateTime.now()}\n' + header;

  // Generate the unmodifiable views
  if (unmodifiable) {
    for (var export in metadata.exported) {
      print(export.name);
      print(export.filename);

      // Get the path
      var unmodifiableFilename = 'unmodifiable_${export.filename.split('.')[0]}_view.dart';
      var outputPath = path.join(currentPath, unmodifiablePath, unmodifiableFilename);

      print(outputPath);

      // Get the relative path for the importer
      var directory = path.dirname(unmodifiableLibrary);
      print(directory);

      var relativePath = path.relative(outputPath, from: directory);
      print(relativePath);

      await _writeUnmodifiableLibrary(export, outputPath);
    }
  }

  // Generate the converters
  if (converters) {
    await _writeConverterLibrary(metadata, converterLibrary, converterPath, packageName, header);
  }
}

/// Writes the converters for a library with the given [metadata] to the [outputPath].
///
/// Any sublibraries are written to [outputLibrariesTo] by recursively calling
/// the function.
Future<Null> _writeConverterLibrary(LibraryMetadata metadata,
                                      String outputPath,
                                      String outputLibrariesTo,
                                      String packageName,
                                      String header) async
{
  // Get the directory of the outputPath so relative urls can be generated.
  var directory = path.dirname(outputPath);
  print(directory);

  var standardLibraries = ['dart:convert'];
  var importPaths = [];
  var exportPaths = [];

  for (var import in metadata.imported) {
    var filename = _converterFilename(import);
    var importPath = path.join(outputLibrariesTo, filename);

    // Generate the library recursively
    await _writeConverterLibrary(import, importPath, outputLibrariesTo, packageName, header);

    importPaths.add(_normalizePathSeparators(path.relative(importPath, from: directory)));
  }

  for (var export in metadata.exported) {
    var filename = _converterFilename(export);
    var exportPath = path.join(outputLibrariesTo, filename);

    // Generate the library recursively
    await _writeConverterLibrary(export, exportPath, outputLibrariesTo, packageName, header);

    exportPaths.add(_normalizePathSeparators(path.relative(exportPath, from: directory)));
  }

  // Write the header
  var buffer = new StringBuffer();

  print('Import paths: $importPaths');
  print('Export paths: $exportPaths');

  buffer.writeln(header);
  buffer.writeln('library ${_libraryName(outputPath, packageName)};\n');

  if (standardLibraries.isNotEmpty) {
    for (var library in standardLibraries) {
      buffer.writeln('import \'$library\';');
    }
  }

  if (importPaths.isNotEmpty) {
    for (var importPath in importPaths) {
      buffer.writeln('import \'$importPath\';');
    }

    buffer.writeln();
  }

  if (exportPaths.isNotEmpty) {
    buffer.writeln();

    for (var exportPath in exportPaths) {
      buffer.writeln('export \'$exportPath\';');
    }
  }

  // Get the generated contents
  buffer.writeln(generateConverters(metadata));

  // Write the file
  var file = new File(outputPath);
  await file.writeAsString(buffer.toString());
}

Future<Null> _writeUnmodifiableLibrary(LibraryMetadata metadata, String path) async {
  // Get the generated contents
  var contents = generateUnmodifiableModels(metadata);

  if (contents.isNotEmpty) {
    // Check to see if an dart:collection is required
    var usesCollection =
        contents.contains('UnmodifiableListView') ||
        contents.contains('UnmodifiableMapView');

    var buffer = new StringBuffer();

    var file = new File(path);

    await file.writeAsString(buffer.toString());
    await file.writeAsString(contents);
  }
}

String _libraryName(String outputPath, String packageName) {
  // The lib directory should not be prefixed.
  if (outputPath.startsWith('lib/')) {
    outputPath = outputPath.substring(4);
  }

  print(outputPath);

  var libraryName = packageName;
  var split = path.split(outputPath);

  for (var value in split) {
    libraryName += '.' + value;
  }

  print(libraryName);

  return libraryName;
}

String _converterFilename(LibraryMetadata metadata) {
  var basename = path.basenameWithoutExtension(metadata.filename);

  return '${basename}_convert.dart';
}

String _unmodifiableFilename(LibraryMetadata metadata) {
  var basename = path.basenameWithoutExtension(metadata.filename);

  return 'unmodifiable_${basename}_view.dart';
}

/// Normalizes the path separators to use '/' for generating imports/exports.
///
/// This is done to handle Windows systems as the path library does not handle
/// any sort of normalization.
String _normalizePathSeparators(String path) {
  return path.replaceAll('\\', '/');
}
